#+TITLE: EECS 493 Notes
#+AUTHOR: Stephen Brennan
#+OPTIONS: tex:t
#+STARTUP: entitiespretty

* 2015-08-24 Monday

  - I'm definitely going to switch to undergrad version of this class.
  - Quizzes - 60%
  - Project - 40%.
  - "Try" to get 8-10 quizzes.
  - Drop 2 lowest quizzes.

** Software Engineering

   Multiple meanings:

   - Application of engineering principles to software development.  Whatever
     those "engineering principles" are.
     - NATO stuff - many NATO countries had to do military software dev.
     - They held a conference to solve their problems by applying engineering
       practices.
     - Specification documents, etc.
   - Name of the software engineering practice.
   - Something else

***   Goals of Saftware Engineering

      To produce, as quickly and inexpensively as possible, software that is:

      - Easy to use
      - Reliable
      - Something
      - Straightforward to maintain, adapt, and enhance
      - Secure (lol)

      Generally most of software engineering is actually maintaining, adapting,
      and enhancing.  Not constructing.

*** Aspects of Software Engineering

**** Technical

       - Specification - creating a document that says exactly what a software or
         subsystem will do.
       - Design - taking a specification and coming up with a "design" that will
         do what the spec says.  Design is high level (not code), like UML, etc.
       - Programming - taking the design and putting it into code.
       - Inspection and Testing
       - Static & dynamic analysis
       - Debugging
       - Maintenance
       - Configuration management

**** Non-Technical

     - Project management
     - Psychology
       - cognitive, behavioral, organization
     - Law
       - contracts, liability, intellectual property

*** Software Complexity

    Primary issue for software dev: complexity:

    - problem complexity
    - design/implementation complexity
    - platform complexity

    Large systems are among the most complex things produced by humans.
    (e.g. Windows 8.1 - 80 million lines of code).

    - Complex systems are difficult to understand, produce, and maintain.
    - They rarely satisfy every need, and the needs often are a moving target.
    - They always contain "residual defects" that you don't know about.
    - Many SD projects are late and over budget.
      - Some just never complete.

*** Software Engineering Methodology

    - Broad collection of techniques and tools addressing each phase of software
      development.
    - Continually evolving
    - Specialized for subfields:
      - Web
      - Real-time
      - Health
    - Influential methods:
      - OO
      - TDD
      - Agile

* 2015-08-26 Wednesday

** Software Process Models

   - Graphical models of the software development process.
   - Characterize workflow
   - Have descriptive and prescriptive purposes
     - Some people advocate models that will help you make better software.

*** Anti-model: Build & Fix

    - Build first version
    - Modify until client is satisfied

    Problems with this:

    - Product is implemented without specification or design documents. (!)
      - Lack of planning... it sucks.
    - Reworked until the client is satisfied.
      - This is a moving target.
    - Works poorly for large products.
    - Maintenance is likely to be very difficult.

    Ways to improve:

    - Add a requirements document.
    - Add a planning stage.

*** Basic Waterfall Model

    - Phases: (this is kinda a combination of multiple slides)
      - Requirements
        - Elicitation and analysis: determine what it should do.  This is a good
          time to meet with a client and help them describe exactly what their
          software should do.
        - Specification: after your analysis, you write a specification of what
          the software should do.  Called SRS
      - Design: intermediate between requirements and implementation.  Describes
        the structure and behavior in a way that satisfies the requirements, but
        doesn't actually implement it.
      - Implementation: coding yo.
      - Validation: the set of activities that you do to make sure you deliver
        the right product.
        - Testing!!
        - Previews for customer to make sure they're satisfied.
        - Integration - combining the components into a working system.
        - Deployment - send out teh binaries
      - Maintenance: repair, adapt, or enhance the system as needed.
    - Pretty much all software development models will contain some variation of
      these phases, but not necessarily in the same order, or linearly.
    - Stage called "Verification" is for formal reasoning and proofs of
      correction.

**** Waterfall Augmented With Iteration

     - Basically adds a whole bunch of transitions, to make maintenance more
       nice.

**** Waterfall  Advantages

     - It is disciplined, if you do it right.  Which is much better than just
       "build and fix."
     - If you're careful, the analysis+docs can prevent costly problems later.
     - Documentation typically fall out of date, so it takes a ton of effort to
       "be careful".

**** Waterfall Disadvantages

     - Difficult to convey dynamics of a system in a document.
     - Customers often can't tell what they want/don't want until they see it.
     - Requirements can also change for reasons other than shifting wants.
     - Sometimes you only really understand the requirements when you try to
       implement them.
     - Diffcult to assess your progress until some things are implemented.

*** Incentive Mismatch

    - Schrage claims requirements create perverse incentives for clients to:
      - Avoid rigorous thinking about cost, change, priorities, and risk.
      - Delegate hard design decisions to software developers.
    - It's easy and inexpensive to come up with many requirements.  They're
      "wishes".  It's easy.
    - Developers are rewarded for building to requirements.
    - Not rewarded for finding and removing requirements.
    - Schrage argues for quick prototypes based on few requirements.
      - "Never go to a client meeting without a prototype."
      - This fosters ongoing client interaction in development.
      - Clients are also less likely to reject their own work.
